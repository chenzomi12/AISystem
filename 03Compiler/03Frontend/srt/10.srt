1
00:00:00,000 --> 00:00:04,466
字幕生成：qiaokai 字幕校对：mkwei

2
00:00:06,200 --> 00:00:07,500
嗨大家好

3
00:00:08,100 --> 00:00:09,100
我是 ZOMI

4
00:00:09,100 --> 00:00:10,133
那其实大家

5
00:00:10,400 --> 00:00:11,566
大家会发现

6
00:00:11,566 --> 00:00:13,266
我一般录视频的时间呢

7
00:00:13,266 --> 00:00:16,699
都在晚上 11 点 12 点 1 点之间

8
00:00:16,866 --> 00:00:17,366
嗯

9
00:00:17,366 --> 00:00:19,899
就是没有利用工作的时间去做这个事

10
00:00:20,100 --> 00:00:21,533
我觉得还是比较有意义

11
00:00:21,533 --> 00:00:23,399
那今天呢我们回到正式的话题

12
00:00:23,400 --> 00:00:26,400
就是 AI 编译器系列里面的前端优化

13
00:00:26,966 --> 00:00:28,966
今天我要给大家汇报的内容呢

14
00:00:28,966 --> 00:00:30,766
叫做代数简化

15
00:00:30,800 --> 00:00:31,600
那可以看到啊

16
00:00:31,600 --> 00:00:34,933
其实我们之前呢像炼金一样讲了很多

17
00:00:35,366 --> 00:00:37,333
AI 编译器前端的各种优化

18
00:00:37,333 --> 00:00:38,599
数据内存的布局

19
00:00:38,600 --> 00:00:39,500
内存的分配

20
00:00:39,500 --> 00:00:42,800
常量折叠公共子表达式消除讲了很多

21
00:00:42,933 --> 00:00:45,599
每一个内容呢看上去都独立无关

22
00:00:45,600 --> 00:00:46,600
比较零散

23
00:00:48,066 --> 00:00:48,766
但实际上呢

24
00:00:48,766 --> 00:00:51,799
我们还是围绕着 AI 编译器的前端优化

25
00:00:51,900 --> 00:00:55,466
输入呢是 AI 框架产生的计算图 Graph IR

26
00:00:55,500 --> 00:00:57,500
我们之前讲每一个单独的内容呢

27
00:00:57,500 --> 00:00:59,000
都可以作为 AI 编译器里面

28
00:00:59,000 --> 00:01:01,300
前端的一个独立的 pass

29
00:01:01,466 --> 00:01:03,533
虽然我们讲了很多零散的内容

30
00:01:03,600 --> 00:01:07,133
但这并不意味着计算图的优化

31
00:01:07,133 --> 00:01:09,533
前端的优化只有这几个 pass

32
00:01:09,700 --> 00:01:12,466
希望大家一起去贡献前端优化的 pass

33
00:01:12,466 --> 00:01:14,799
让我们前端优化的 pass 更加明确

34
00:01:15,066 --> 00:01:17,499
而这里面呢有一点值得注意的就是

35
00:01:17,500 --> 00:01:18,766
虽然我们在前端优化

36
00:01:18,766 --> 00:01:20,933
但实际上呢在我们训练场景

37
00:01:20,966 --> 00:01:24,733
推理场景他都有所不同和有所侧重

38
00:01:24,733 --> 00:01:25,799
那我们今天

39
00:01:27,200 --> 00:01:29,266
回到我们今天的内容代数简化了

40
00:01:29,266 --> 00:01:30,999
代数简化了主要分为三个

41
00:01:31,000 --> 00:01:32,766
一个是算数的代数简化

42
00:01:32,800 --> 00:01:35,700
一个是运行的简化一个是广播的简化

43
00:01:35,800 --> 00:01:37,666
20 年后的今天

44
00:01:37,666 --> 00:01:42,199
我才发现初中的数学真的是有用

45
00:01:42,900 --> 00:01:43,766
现在我们来看一下

46
00:01:43,800 --> 00:01:45,900
三个有什么不一样的区别

47
00:01:46,333 --> 00:01:47,899
死外边从这跳下去

48
00:01:47,900 --> 00:01:49,866
不会吃你们一点东西啊

49
00:01:49,866 --> 00:01:50,966
真香哎呀

50
00:01:52,866 --> 00:01:54,699
那你放的草都没有分开

51
00:01:55,900 --> 00:01:58,300
代数简化呢主要是利用交换律了

52
00:01:58,300 --> 00:02:01,000
结合律了等这些数学的代数的规律

53
00:02:01,000 --> 00:02:03,566
去调整我们计算图里面的执行顺序

54
00:02:03,566 --> 00:02:05,533
或者删除我们计算图里面

55
00:02:05,600 --> 00:02:08,066
没有必要存在的一些算子

56
00:02:08,066 --> 00:02:10,799
来提高我们整个计算图的运行效率

57
00:02:12,200 --> 00:02:13,266
而我们想要去

58
00:02:13,266 --> 00:02:15,399
实现这个代数简化的工作呢

59
00:02:15,400 --> 00:02:17,600
我们可以通过两种方式来实现

60
00:02:17,666 --> 00:02:19,533
那最主要的一个通用的逻辑

61
00:02:19,533 --> 00:02:20,966
就是通过子图的替换

62
00:02:20,966 --> 00:02:24,133
把一些子图换成另外一种子图的方式

63
00:02:24,200 --> 00:02:25,166
那具体的实现呢

64
00:02:25,166 --> 00:02:26,933
我们可以抽象出一套通用

65
00:02:26,933 --> 00:02:28,466
子图的替换的框架

66
00:02:28,733 --> 00:02:31,099
然后对我们提前设定好的规则呢

67
00:02:31,100 --> 00:02:32,166
进行一个实例化

68
00:02:32,166 --> 00:02:32,899
第二种方式呢

69
00:02:32,900 --> 00:02:35,000
我们可以针对每一个具体的规则呢

70
00:02:35,000 --> 00:02:37,000
去实现专门的优化的逻辑

71
00:02:37,366 --> 00:02:38,999
所以这里面很重要的一点就是

72
00:02:39,000 --> 00:02:41,100
我们需要去发现规则

73
00:02:41,100 --> 00:02:42,266
发现规律

74
00:02:42,300 --> 00:02:43,966
编译器就是做这个作用

75
00:02:43,966 --> 00:02:45,499
而发现规律呢

76
00:02:45,500 --> 00:02:46,866
是系统工程师

77
00:02:46,866 --> 00:02:49,299
AI 工程师去专门去做

78
00:02:49,533 --> 00:02:50,733
所以 AI 工程师呢

79
00:02:50,733 --> 00:02:52,999
他其实也可以做很多不同的优化

80
00:02:53,000 --> 00:02:54,800
也可以发现很多规律

81
00:02:54,800 --> 00:02:56,466
而且他需要懂算法

82
00:02:56,466 --> 00:02:58,399
才能够更好的知道子图

83
00:02:58,400 --> 00:03:00,700
计算图长成什么样子

84
00:03:02,400 --> 00:03:04,800
现在我们来看看第一个就是算数优化

85
00:03:04,800 --> 00:03:05,666
那算数优化呢

86
00:03:05,666 --> 00:03:07,266
最重要的就是利用我们

87
00:03:07,266 --> 00:03:09,366
代数之间的一个运算逻辑

88
00:03:09,400 --> 00:03:10,500
在计算图里面呢

89
00:03:10,500 --> 00:03:12,466
确定我们整个优化的方法

90
00:03:12,500 --> 00:03:14,000
我们现在往下看一下

91
00:03:14,200 --> 00:03:15,700
算数优化里面的第一种呢

92
00:03:15,700 --> 00:03:18,333
就是结合律的一个化简

93
00:03:18,733 --> 00:03:20,766
可以看到我们这里面举一个

94
00:03:20,766 --> 00:03:22,666
最简单的例子 a 乘以跟号 b

95
00:03:22,666 --> 00:03:24,299
再乘以根号 b 乘以根号 c

96
00:03:24,600 --> 00:03:25,933
那两个根号 b 呢

97
00:03:25,933 --> 00:03:28,399
我们可以结合变成 a 乘以 b 乘以 c

98
00:03:28,900 --> 00:03:29,766
这种方式

99
00:03:29,766 --> 00:03:32,566
而当然呢我们有非常多的不同的规则

100
00:03:32,566 --> 00:03:35,133
那这些规则呢都是我们提前发现好

101
00:03:35,133 --> 00:03:37,799
现在我们来看一下一个最具体的例子

102
00:03:38,166 --> 00:03:40,499
我们现在左边的这个计算图呢

103
00:03:40,500 --> 00:03:43,366
就是对应于上面公式的左边

104
00:03:43,566 --> 00:03:45,799
a 和 b 进行卷积之后呢求逆

105
00:03:46,000 --> 00:03:48,066
然后呢 a 和 b 进行卷积的结果呢

106
00:03:48,066 --> 00:03:50,066
给 c 进行一个相乘

107
00:03:50,133 --> 00:03:51,066
最后求逆

108
00:03:51,066 --> 00:03:52,999
最后把这两个结果再相乘

109
00:03:53,166 --> 00:03:55,533
这么一个简单的一个计算逻辑

110
00:03:55,600 --> 00:03:58,266
实际上呢我们可以把红色的这个框呢

111
00:03:58,266 --> 00:03:59,133
提取出来

112
00:03:59,166 --> 00:04:01,166
我们可以把 a 跟 b 进行卷积

113
00:04:01,166 --> 00:04:02,099
这个计算呢

114
00:04:02,466 --> 00:04:05,266
提取出来 a 跟 b 这个计算呢提取出来

115
00:04:05,300 --> 00:04:07,133
变成右边的这条公式

116
00:04:07,133 --> 00:04:07,966
那这条公式呢

117
00:04:07,966 --> 00:04:08,999
对应的计算图

118
00:04:09,000 --> 00:04:10,966
就是我们右边的这个计算图

119
00:04:11,066 --> 00:04:12,066
可以可以看到了

120
00:04:12,066 --> 00:04:13,866
我们节省了很多的算子

121
00:04:13,866 --> 00:04:16,666
也节省了我们真正的运算的开销

122
00:04:16,900 --> 00:04:18,900
这个就是结合律的化简

123
00:04:21,066 --> 00:04:24,099
接下来我们看一下第二个算数化简

124
00:04:24,100 --> 00:04:27,000
提取公因式或者分配律的化简

125
00:04:27,666 --> 00:04:29,333
下面呢我有一条公式

126
00:04:29,466 --> 00:04:31,599
a 乘以 c 加上 a 乘以 b

127
00:04:31,733 --> 00:04:34,266
那这个时候呢我们可以把 a 提取出来

128
00:04:34,266 --> 00:04:35,766
然后 b 加 c 乘以 a

129
00:04:35,766 --> 00:04:37,733
当然呢我们提取公因式和

130
00:04:37,733 --> 00:04:39,199
分配律的这种化简呢

131
00:04:39,266 --> 00:04:40,499
有非常多的规则

132
00:04:40,500 --> 00:04:42,400
这里面呢我们简单列了三条

133
00:04:42,966 --> 00:04:45,366
接下来呢我们看一下具体的一个例子

134
00:04:45,366 --> 00:04:47,099
a 乘以 c 加上 a 乘以 b

135
00:04:47,100 --> 00:04:49,466
那我们可以把 a 加 b 提取出来乘以 c

136
00:04:49,566 --> 00:04:52,466
那就类似于下面这个图所示

137
00:04:52,500 --> 00:04:55,933
我现在呢 A GEMM B 就是矩阵乘

138
00:04:57,066 --> 00:04:58,966
接着呢把这个结果给 c

139
00:04:58,966 --> 00:05:01,799
把这个结果给 d 然后再进行相加

140
00:05:01,800 --> 00:05:04,400
这个对应的就是我们左边的这条公式

141
00:05:04,566 --> 00:05:07,166
实际上呢进行了提取公因式之后呢

142
00:05:07,166 --> 00:05:09,566
我们就可以把 a 加上 b 提取出来

143
00:05:09,566 --> 00:05:11,299
然后把右边的这个框

144
00:05:11,300 --> 00:05:14,600
刚才三个公式变成只有两个公式了

145
00:05:16,466 --> 00:05:18,933
最后一个就是交换律化减

146
00:05:18,933 --> 00:05:20,399
那交换律其实很简单

147
00:05:20,466 --> 00:05:22,866
我们以一个最简单的例子来看看

148
00:05:22,866 --> 00:05:23,333
首先呢

149
00:05:23,333 --> 00:05:25,266
我们先对 a 执行一个移位的操作

150
00:05:25,266 --> 00:05:26,966
然后对它进行 ReduceSum

151
00:05:27,100 --> 00:05:29,100
其实呢我们可以把它转换成为

152
00:05:29,100 --> 00:05:30,566
先进行 ReduceSum

153
00:05:30,933 --> 00:05:32,533
再进行移位的操作

154
00:05:32,566 --> 00:05:34,699
那这种方式呢就是交换律

155
00:05:34,700 --> 00:05:37,266
把两个算子或者两个算符的操作呢

156
00:05:37,266 --> 00:05:38,166
进行个交换

157
00:05:38,166 --> 00:05:39,199
有什么好处吗

158
00:05:39,766 --> 00:05:40,966
a 它是一个张量

159
00:05:40,966 --> 00:05:43,566
我对张量里面每一个元素呢进行位移

160
00:05:43,933 --> 00:05:45,399
他需要很多次运算

161
00:05:45,400 --> 00:05:47,100
然后我再把运算后的结果呢

162
00:05:47,100 --> 00:05:48,166
进行一个聚合

163
00:05:48,200 --> 00:05:50,933
那我倒不如先对数据进行聚合

164
00:05:50,933 --> 00:05:52,266
拿到一个小批量

165
00:05:52,266 --> 00:05:54,333
结果之后呢再进行位移

166
00:05:54,533 --> 00:05:54,933
这个时候呢

167
00:05:54,933 --> 00:05:57,599
就可以大量的减少我们整体的运算了

168
00:05:57,600 --> 00:05:59,933
这种就是交换律带来的好处

169
00:06:01,666 --> 00:06:03,566
刚才我提到的这几种方式呢

170
00:06:03,566 --> 00:06:06,166
其实在这篇文章 DNNFusion 里面呢

171
00:06:06,166 --> 00:06:06,966
都有介绍

172
00:06:06,966 --> 00:06:09,399
我也非常鼓励大家去看看这篇文章

173
00:06:11,500 --> 00:06:14,166
接下来我们讲另外一个化简的方法

174
00:06:14,166 --> 00:06:14,966
就是运行化简

175
00:06:14,966 --> 00:06:17,399
主要的目的呢就是减少运算

176
00:06:17,400 --> 00:06:18,466
或者执行的时候

177
00:06:18,600 --> 00:06:21,500
冗余的算子或者冗余的算子对

178
00:06:21,500 --> 00:06:23,600
现在我们来看看具体的两个例子

179
00:06:23,600 --> 00:06:25,700
第一个呢就是对逆函数

180
00:06:25,800 --> 00:06:27,733
第一个呢就是对逆函数

181
00:06:28,200 --> 00:06:29,666
对逆函数这个数学概念呢

182
00:06:29,666 --> 00:06:32,533
就是等于自身函数的对合算子

183
00:06:32,600 --> 00:06:34,800
例如有取反、倒数、逻辑非

184
00:06:34,800 --> 00:06:36,766
还有矩阵转置这种方式

185
00:06:36,766 --> 00:06:39,199
那下面这条公式呢其实就很明显了

186
00:06:39,200 --> 00:06:42,466
f(f(x))呢是等于 x 本身

187
00:06:43,200 --> 00:06:45,933
另外还有 f(x)呢就等于 f(x)的逆

188
00:06:46,300 --> 00:06:49,666
那第二种呢就是幂等算子的化简呢

189
00:06:49,666 --> 00:06:50,699
它最重要的算子呢

190
00:06:50,700 --> 00:06:52,000
就是作用在某一元素

191
00:06:52,000 --> 00:06:53,666
两次其实等于一次

192
00:06:53,733 --> 00:06:57,266
那我们看这条公式很明显 f(f(x))呢

193
00:06:57,266 --> 00:06:58,866
等于 f(x)

194
00:06:58,866 --> 00:07:01,366
这个可能听上去数学概念比较抽象

195
00:07:01,366 --> 00:07:04,266
我们看一下具体的例子就是 Reshape

196
00:07:04,866 --> 00:07:06,566
我们对 x 进行 Reshape

197
00:07:06,566 --> 00:07:09,666
然后呢对 x 输出的 Reshape 呢再进行 Reshape

198
00:07:09,766 --> 00:07:12,199
其实呢我们干脆直接对 x 进行

199
00:07:12,333 --> 00:07:13,999
第二次 Reshape 就完了

200
00:07:15,700 --> 00:07:17,133
那我们看看具体的公式啊

201
00:07:17,133 --> 00:07:20,899
像对合算子的化解呢可能有 Op1 Op1

202
00:07:20,966 --> 00:07:23,066
Op2 这种对合算子呢

203
00:07:23,066 --> 00:07:24,099
我们其实可以把

204
00:07:24,100 --> 00:07:26,200
相同的对合算子进行优化

205
00:07:26,200 --> 00:07:29,300
把这两个算子都优化了变成只剩下 Op2

206
00:07:29,600 --> 00:07:31,666
这种就是对合算子的化简

207
00:07:31,700 --> 00:07:33,566
第二个呢就是幂等算子的化简

208
00:07:33,566 --> 00:07:35,933
我们可以看到现在呢我们有三个 Op

209
00:07:36,100 --> 00:07:37,266
三个操作

210
00:07:37,300 --> 00:07:38,400
我的输入呢是 a

211
00:07:38,566 --> 00:07:39,766
那幂等算子呢

212
00:07:39,766 --> 00:07:43,133
它就可以把相同的算子变成只有一个

213
00:07:43,366 --> 00:07:45,933
我对 a 进行 Reshape 再对结果进行 Reshape

214
00:07:45,933 --> 00:07:46,799
再第三次 Reshape

215
00:07:46,800 --> 00:07:49,333
其实我可以直接执行一次 Reshape

216
00:07:49,333 --> 00:07:50,333
就可以了

217
00:07:50,333 --> 00:07:52,499
这种就是幂等算子的化简

218
00:07:54,500 --> 00:07:57,166
最后一个内容就是广播化简

219
00:07:57,166 --> 00:07:58,466
什么叫广播化简呢

220
00:07:58,466 --> 00:08:00,266
广播我们叫做 broadcast

221
00:08:00,266 --> 00:08:02,999
在 PyTorch 啊或者 MindSpore、TensorFlow

222
00:08:03,133 --> 00:08:04,733
都有对应的算子

223
00:08:04,733 --> 00:08:06,366
那其实呢我们很好理解

224
00:08:06,466 --> 00:08:08,499
每个算子呢它的 shape 都不一样

225
00:08:08,500 --> 00:08:09,533
但是我们需要

226
00:08:09,733 --> 00:08:11,666
相乘或者相互运算的时候呢

227
00:08:11,666 --> 00:08:14,366
要对张量的形状来进行对齐

228
00:08:14,400 --> 00:08:17,400
而对齐之前呢运用的算子就是 Broadcast

229
00:08:18,733 --> 00:08:19,933
左边的这条公式呢

230
00:08:19,933 --> 00:08:21,766
有四个 Tensor 进行相加

231
00:08:21,766 --> 00:08:24,066
但是呢有两个 Tensor 它是一个矩阵

232
00:08:24,066 --> 00:08:27,133
有两个 Tensor 呢它是一个标量

233
00:08:27,133 --> 00:08:29,533
那这个时候呢矩阵加上标量

234
00:08:29,533 --> 00:08:31,266
再加上矩阵加标量

235
00:08:31,300 --> 00:08:34,366
对应的就是我们左边的这个计算图

236
00:08:35,100 --> 00:08:36,700
首先标量只有一个数

237
00:08:36,700 --> 00:08:38,366
而矩阵张量呢

238
00:08:38,366 --> 00:08:39,399
有四个元素

239
00:08:39,400 --> 00:08:41,866
那这个时候我想要把它们进行相加

240
00:08:41,866 --> 00:08:43,299
就需要语义 shape

241
00:08:43,300 --> 00:08:44,266
上面是对等

242
00:08:44,266 --> 00:08:46,966
所以我们会对 s1 呢进行一个 Broadcast

243
00:08:46,966 --> 00:08:49,199
广播变成一个四维的张量

244
00:08:49,200 --> 00:08:50,966
之后呢才跟 mat1

245
00:08:51,133 --> 00:08:52,733
四维的张量进行相加

246
00:08:52,866 --> 00:08:55,133
右边的这个模块呢也是相同

247
00:08:55,200 --> 00:08:57,166
这样才能够再进行相加

248
00:08:57,200 --> 00:08:59,866
而我们实际上啊我们减少一次 Broadcast

249
00:08:59,866 --> 00:09:00,666
我们可以把

250
00:09:00,933 --> 00:09:03,733
两个标量呢进行相加之后再把它 Broadcast

251
00:09:03,900 --> 00:09:05,733
两个张量直接相加的结果呢

252
00:09:05,733 --> 00:09:06,799
再进行相加

253
00:09:06,800 --> 00:09:09,766
这种方式呢就如右边的这条公式所示

254
00:09:09,866 --> 00:09:11,899
进行了一个广播化简

255
00:09:13,733 --> 00:09:15,799
AI 编辑器的前端优化的内容呢

256
00:09:15,800 --> 00:09:16,933
也到这里为止

257
00:09:18,600 --> 00:09:19,333
谢谢各位

258
00:09:19,333 --> 00:09:20,266
拜了个拜

259
00:09:20,900 --> 00:09:22,700
卷的不行了卷的不行了

260
00:09:22,700 --> 00:09:24,366
记得一键三连加关注哦

261
00:09:24,466 --> 00:09:24,799
所有

262
00:09:24,800 --> 00:09:27,666
的内容都会开源在下面这条链接里面

263
00:09:28,066 --> 00:09:28,999
拜了个拜

